
library(plyr)
# library(Hmisc)
# library(kitagawa)

# need to install package kitagawa 
# http://www.inside-r.org/packages/cran/kitagawa/docs/log2_ticks
# library(lattice)
# library(latticeExtra)


#library(Hmisc)
# library(ggplot2)
# require(cowplot)


# http://www.inside-r.org/packages/cran/kitagawa/docs/log2_ticks
# http://stackoverflow.com/questions/6955440/displaying-minor-logarithmic-ticks-in-x-axis-in-r
minor.ticks.axis <- function(ax,n,t.ratio=0.5,mn,mx,...){

  lims <- par("usr")
  if(ax %in%c(1,3)) lims <- lims[1:2] else lims[3:4]

  major.ticks <- pretty(lims,n=5)
  if(missing(mn)) mn <- min(major.ticks)
  if(missing(mx)) mx <- max(major.ticks)

  major.ticks <- major.ticks[major.ticks >= mn & major.ticks <= mx]

  labels <- sapply(major.ticks,function(i)
            as.expression(bquote(10^ .(i)))
          )
  axis(ax,at=major.ticks,labels=labels,...)

  n <- n+2
  minors <- pretty(10^major.ticks[1:2],n)-major.ticks[1]
  minors <- minors[-c(1,n)]

  minor.ticks = c(outer(minors,major.ticks,`+`))
  minor.ticks <- minor.ticks[minor.ticks > mn & minor.ticks < mx]


  axis(ax,at=minor.ticks,tcl=par("tcl")*t.ratio,  labels=FALSE)
}

# function definition for calculating mean of data 

calulateMeanDataTotaltime <- function(myfilename, n){

totaltime <- matrix(nrow= 5, ncol=n)

# run for all 5 experiments 
for(i in 1:5){
#       file = paste("data/java/resultJavaReadObjects_100_", i,  sep = "")
        file = paste(myfilename, i,  sep = "")
	file <- paste(file, ".txt" , sep="")
	mydata <- read.delim(file, header=TRUE, sep="#")
	totaltime[i,] <-  mydata[['totaltime']]
}

finalTime <- vector() 

for(j in 1:n){
 tmp<-0
	for(i in 1:5){
	tmp= tmp+totaltime[i,j]   
        	}
  tmp=tmp/5
  finalTime[j] <- tmp
}

# print("This is before replacing")
# print(mydata)
mydata$totaltime<-finalTime
return(mydata)
}

# load data for 10 objects read 
data10 <-  calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_10_", 36)
data10$size <-10 

# load data for 100 objects read 
# data100 <- read.delim("data/java/resultJavaReadObjects_100_1.txt", header=TRUE, sep="#")
data100 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_100_", 36)
data100$size <- 100 


# load data for 1000 objects read 
# data1000 <- read.delim("data/java/resultJavaReadObjects_1000_1.txt", header=TRUE, sep="#")
# data1000 <- read.delim("data/java/resultJavaReadObjects_1000_1.txt", header=TRUE, sep="#")
data1000 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_1000_", 36)
data1000$size <-1000 


# load data for 10000 objects read 
#data10000 <- read.delim("data/java/resultJavaReadObjects_10000_1.txt", header=TRUE, sep="#")
data10000 =calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_10000_", 36)
data10000$size <-10000 


# load data for 100000 objects read 
# data100000 <- read.delim("data/java/resultJavaReadObjects_100000_1.txt", header=TRUE, sep="#")
data100000 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_100000_", 36)
data100000$size <-100000 

# load data for 1000000 objects read 
# data100000 <- read.delim("data/java/resultJavaReadObjects_1000000_1.txt", header=TRUE, sep="#")
# data1000000 = calulateMeanDataTotaltime("data/java/resultJavaReadObjects_1000000_")
# data1000000$size <-1000000 



# C Results 
##################################################################
# load data for 10 objects read 
#datac10 <- read.delim("data/C_Results/resultsC_10.txt", header=TRUE, sep="#")
datac10 = calulateMeanDataTotaltime("data/C_Results/results_10_", 24)
datac10$size <-10 

# load data for 100 objects read 
# datac100 <- read.delim("data/C_Results/resultsC_100.txt", header=TRUE, sep="#")
datac100 = calulateMeanDataTotaltime("data/C_Results/results_100_", 24)
datac100$size <-100 


# load data for 1000 objects read 
#datac1000 <- read.delim("data/C_Results/resultsC_1000.txt", header=TRUE, sep="#")
datac1000 = calulateMeanDataTotaltime("data/C_Results/results_1000_", 24)
datac1000$size <-1000 


# load data for 10000 objects read 
#datac10000 <- read.delim("data/C_Results/resultsC_10000.txt", header=TRUE, sep="#")
datac10000 = calulateMeanDataTotaltime("data/C_Results/results_10000_", 24)
datac10000$size <-10000 

# load data for 10000 objects read 
# datac100000 <- read.delim("data/C_Results/resultsC_100000.txt", header=TRUE, sep="#")
datac100000 = calulateMeanDataTotaltime("data/C_Results/results_100000_", 24)
datac100000$size <-100000


# bind the data frames together 
# data <- rbind(data10, data100, data1000, data10000, data100000)
data <- rbind(data10, data100, data1000, data10000, data100000, datac10, datac100, datac1000, datac10000, datac100000)
print(data)

##################################################################
##################################################################
##################################################################
##################################################################

data1 <- rbind(data10, data100, data1000, data10000,  datac10, datac100, datac1000, datac10000)
partJavaSeq <- subset(data, datatype == "Part" & seq=="true" & method=="JAVADEFAULT")
partSeq <- vector()
partSeq <-partJavaSeq[['totaltime']]


partJava <- subset(data1, datatype == "Part" & seq=="false" & method=="JAVADEFAULT")
part <- vector()
part <-partJava[['totaltime']]



# JSON results 
partJsonSeq <- subset(data, datatype == "Part" & seq=="true" & method=="JSON")
partJsonSeqV <- vector()
partJsonSeqV <-partJsonSeq[['totaltime']]

partJson <- subset(data1, datatype == "Part" & seq=="false" & method=="JSON")
partJsonV <- vector()
partJsonV <-partJson[['totaltime']]



# PROTOCOL results 
partPROTOCOLSeq <- subset(data, datatype == "Part" & seq=="true" & method=="PROTOCOL")
partPROTOCOLSeqV <- vector()
partPROTOCOLSeqV <-partPROTOCOLSeq[['totaltime']]

partPROTOCOL <- subset(data1, datatype == "Part" & seq=="false" & method=="PROTOCOL")
partPROTOCOLV <- vector()
partPROTOCOLV <-partPROTOCOL[['totaltime']]

# KRYO results 
partKRYOSeq <- subset(data, datatype == "Part" & seq=="true" & method=="KRYO")
partKRYOSeqV <- vector()
partKRYOSeqV <-partKRYOSeq[['totaltime']]

partKRYO <- subset(data1, datatype == "Part" & seq=="false" & method=="KRYO")
partKRYOV <- vector()
partKRYOV <-partKRYO[['totaltime']]


# ByteBuffer results 
partByteBufferSeq <- subset(data, datatype == "Part" & seq=="true" & method=="BYTEBUFFER")
partByteBufferSeqV <- vector()
partByteBufferSeqV <-partByteBufferSeq[['totaltime']]

partByteBuffer <- subset(data1, datatype == "Part" & seq=="false" & method=="BYTEBUFFER")
partByteBufferV <- vector()
partByteBufferV <-partByteBuffer[['totaltime']]


# BSON results 
partBsonSeq <- subset(data, datatype == "Part" & seq=="true" & method=="BSON")
partBsonSeqV <- vector()
partBsonSeqV <-partBsonSeq[['totaltime']]

partBson <- subset(data1, datatype == "Part" & seq=="false" & method=="BSON")
partBsonV <- vector()
partBsonV <-partBson[['totaltime']]


# C++  HANDCODED  results 
partHANDCODEDSeq <- subset(data, language="ReadTimeCPP", datatype == "Part" & seq=="true" & method=="HANDCODED")
partHANDCODEDSeqV <- vector()
partHANDCODEDSeqV <-partHANDCODEDSeq[['totaltime']]

partHANDCODED <- subset(data1, language="ReadTimeCPP", datatype == "Part" & seq=="false" & method=="HANDCODED")
partHANDCODEDV <- vector()
partHANDCODEDV <-partHANDCODED[['totaltime']]



# C++  PROTOBUF  results 
partCPROTOBUFSeq <- subset(data, language="ReadTimeCPP", datatype == "Part" & seq=="true" & method=="PROTOBUF")
partCPROTOBUFSeqV <- vector()
partCPROTOBUFSeqV <-partCPROTOBUFSeq[['totaltime']]

partCPROTOBUF <- subset(data1, language="ReadTimeCPP", datatype == "Part" & seq=="false" & method=="PROTOBUF")
partCPROTOBUFV <- vector()
partCPROTOBUFV <-partCPROTOBUF[['totaltime']]


# C++  INPLACE  results 
partINPLACESeq <- subset(data, language="ReadTimeCPP", datatype == "Part" & seq=="true" & method=="INPLACE")
partINPLACESeqV <- vector()
partINPLACESeqV <-partINPLACESeq[['totaltime']]

partINPLACE <- subset(data1, language="ReadTimeCPP", datatype == "Part" & seq=="false" & method=="INPLACE")
partINPLACEV <- vector()
partINPLACEV <-partINPLACE[['totaltime']]


# C++  BOOST  results 
partBOOSTSeq <- subset(data, language="ReadTimeCPP", datatype == "Part" & seq=="true" & method=="BOOST")
partBOOSTSeqV <- vector()
partBOOSTSeqV <-partBOOSTSeq[['totaltime']]

partBOOST <- subset(data1, language="ReadTimeCPP", datatype == "Part" & seq=="false" & method=="BOOST")
partBOOSTV <- vector()
partBOOSTV <-partBOOST[['totaltime']]

# print(data)
# print("Sequential Read, java, json, protocol, kryo, bytebuffer")
# print("JSON", partJsonSeqV)
# print(partSeq)
# print(partPROTOCOLSeqV)
# print(partKRYOSeqV)
# print(partByteBufferSeqV)
# print("Random Read, java, json, protocol, kryo, bytebuffer")
# print(part)
# print(partJsonV)
# print(partPROTOCOLV)
# print(partKRYOV)
# print(partByteBufferV)

#print(subset(data, datatype == "Part" & seq=="true" & (method=="JAVADEFAULT" | method=="KRYO") ))

# json, java, protocol, kryo, bytebuffer
#################################################
#######     Plots       #########################
#################################################
pdf(file='Experiment1Part.pdf')

old.par<-par(mfrow=c(1, 2), oma=c(0.1, 0.1, 0.1, 0.1),  pty="m")

# old.par <- par(mfrow=c(1, 2), pty="m")
# op <- par(mar = c(0.1, 4, 0.1, 0.2) + 0.1)
op <- par(mar = c(4, 4, 0.1, 0.1))
# par(xlog=TRUE,  xaxp= c(1, 4, 3)) - Read more at: http://scl.io/dEi79FVa#gs.dg=0AyI
# par(asp=1, pty="s")
# par(asp=4)

x <- c(10, 100, 1000, 10000, 100000)

# JSON
plot(partJsonSeqV, log="y", type="o", pch=2, lty=2, col="darkred",   ylim=c(0.002, 6), axes=FALSE, ann=FALSE, panel.first=abline(h=c(0.001, 0.01, 0.05, 0.1, 0.3, 0.5, 1, 2, 4, 6), v=c(1, 2, 3, 4, 5, 6), lty=3, col="gray"))

# Make x axis using one to 7 labels
axis(1, at=c(1, 2, 3, 4, 5), labels=c("10","100","1k","10k", "100k"), las=2 )

axis(2, las=1, at = c(0.001, 0.01, 0.05, 0.1, 0.3, 0.5, 1, 2, 4, 6), labels=c( "0.001", "0.01", "0.05",  "0.1", "0.3","0.5", "1", "2", "4", "6"))
# axis(2, las=1, labels=FALSE)
# logticks(ax = 2, n.minor = 9, t.ratio = 0.5, major.ticks = NULL)
#logticks(ax = 2, n.minor = 9, t.ratio = 0.9)
# minor.ticks.axis(2, 9, mn=0, mx=2)

#lines for JAVA Default
lines(partSeq , type="o", pch=3, lty=2, col="green")

#lines for BSON
lines(partBsonSeqV, type="o", pch=4, lty=2, col="blue")

#lines for Protocol Buffer 
lines(partPROTOCOLSeqV, type="o", pch=5, lty=2, col="red")

#lines for KRYO
lines(partKRYOSeqV, type="o", pch=6, lty=2, col="green4")

#lines for ByteBuffer
lines(partByteBufferSeqV, type="o", pch=7, lty=2, col="blue1")

#lines for BOOST C++ 
lines(partBOOSTSeqV, type="o", pch=8, lty=2, col="violet")

#lines for PROTOBUF C++ 
lines(partCPROTOBUFSeqV, type="o", pch=9, lty=2, col="orange")

#lines for HANDCODED C++ 
lines(partHANDCODEDSeqV, type="o", pch=10, lty=2, col="deepskyblue")

#lines for INPLACE C++ 
lines(partINPLACESeqV, type="o", pch=11, lty=2, col="blue3")


title(xlab="Number of Objects", col.lab=rgb(0,0.5,0))
title(ylab="Total Reading Time (sec) - log", col.lab=rgb(0,0.5,0))
text(2.6, 3.2, "Part - Sequential", cex=1.4)
# legend(1.2, 3.1, c("Java JSON GZIP",  "Java Default" , "Java BSON" , "Java Protocol", "Java Kryo", "Java ByteBuffer", "C++ Boost",  "C++ Protocol",  "C++ HandCoded", "C++ InPlace"), cex=0.8,  col=c("darkred", "green","blue", "red","green4", "blue1", "violet", "orange", "deepskyblue" , "blue3"), pch=2:11, lty=2:2);
# Create box around plot
box()

##############################################################
##################                   #########################
##################      Next Plot    #########################
##################                   #########################
##############################################################
op <- par(mar = c(4, 4, 0.1, 0.1))

x <- c(10, 100, 1000, 10000)
# JSON
plot(partJsonV, log="y", type="o", pch=2, lty=2, col="darkred", ylim=c(0.01, 14), axes=FALSE, ann=FALSE , panel.first=abline(h=c(0.01, 0.05, 0.1, 0.3,  0.5, 1, 2, 4, 6 , 8, 10, 14), v=c(1, 2, 3, 4), lty=3, col="gray") )

# Make x axis using one to 7 labels
axis(1, at=c(1, 2, 3, 4), lab=c("10", "100","1k","10k") , las = 2 )
axis(2, las=1, at = c(0.01, 0.05, 0.1, 0.3,  0.5, 1, 2, 4, 6 , 8, 10, 14), labels=c("0.01", "0.05", "0.1", "0.3","0.5", "1", "2", "4", "6", "8", "10", "14"))


#lines for JAVA Default
lines(part , type="o", pch=3, lty=2, col="green")

#lines for BSON
lines(partBsonV , type="o", pch=4, lty=2, col="blue")

#lines for Protocol Buffer 
lines(partPROTOCOLV, type="o", pch=5, lty=2, col="red")

#lines for KRYO
lines(partKRYOV, type="o", pch=6, lty=2, col="green4")


#lines for ByteBuffer
lines(partByteBufferV, type="o", pch=7, lty=2, col="blue1")


#lines for BOOST C++ 
lines(partBOOSTV, type="o", pch=8, lty=2, col="violet")

#lines for PROTOBUF C++ 
lines(partCPROTOBUFV, type="o", pch=9, lty=2, col="orange")

#lines for HANDCODED C++ 
lines(partHANDCODEDV, type="o", pch=10, lty=2, col="deepskyblue")

#lines for INPLACE C++ 
lines(partINPLACEV, type="o", pch=11, lty=2, col="blue3")

print("INPLACE results and Boost")
print(partINPLACEV)

print("BOOST results")
print(partBOOSTV)


title(xlab="Number of Objects", col.lab=rgb(0,0.5,0))
title(ylab="Total Reading Time (sec) - log", col.lab=rgb(0,0.5,0))

text(2, 8, "Part - Random", cex=1.4)

# Create box around plot
box()

legend(1.95, 0.13, c("Java JSON GZIP",  "Java Default" , "Java BSON" , "Java Protocol", "Java Kryo", "Java ByteBuffer", "C++ Boost",  "C++ Protocol",  "C++ HandCoded", "C++ InPlace"), cex=0.9,  col=c("darkred", "green","blue", "red","green4", "blue1", "violet", "orange", "deepskyblue" , "blue3"), pch=2:11, lty=2:2)

par(old.par)
par(xpd=TRUE)

# par(xpd=TRUE)
