
library(plyr)
# library(ggplot2)
# require(cowplot)


# function definition for calculating mean of data 

calulateMeanDataTotaltime <- function(myfilename, n){
  
  totaltime <- matrix(nrow= 5, ncol=n)
  
  # run for all 5 experiments 
  for(i in 1:5){
    #       file = paste("data/java/resultJavaReadObjects_100_", i,  sep = "")
    file = paste(myfilename, i,  sep = "")
    file <- paste(file, ".txt" , sep="")
    mydata <- read.delim(file, header=TRUE, sep="#")
    totaltime[i,] <-  mydata[['totaltime']]
  }
  
  finalTime <- vector() 
  
  for(j in 1:n){
    tmp<-0
    for(i in 1:5){
      tmp= tmp+totaltime[i,j]   
    }
    tmp=tmp/5
    finalTime[j] <- tmp
  }
  
  # print("This is before replacing")
  # print(mydata)
  mydata$totaltime<-finalTime
  return(mydata)
}

# load data for 10 objects read 
#data10 <-  calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_10_", 36)
#data10$size <-10 

# load data for 100 objects read 
# data100 <- read.delim("data/java/resultJavaReadObjects_100_1.txt", header=TRUE, sep="#")
#data100 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_100_", 36)
#data100$size <- 100 


# load data for 1000 objects read 
# data1000 <- read.delim("data/java/resultJavaReadObjects_1000_1.txt", header=TRUE, sep="#")
# data1000 <- read.delim("data/java/resultJavaReadObjects_1000_1.txt", header=TRUE, sep="#")
#data1000 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_1000_", 36)
#data1000$size <-1000 


# load data for 10000 objects read 
#data10000 <- read.delim("data/java/resultJavaReadObjects_10000_1.txt", header=TRUE, sep="#")
#data10000 =calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_10000_", 36)
#data10000$size <-10000 


# load data for 100000 objects read 
# data100000 <- read.delim("data/java/resultJavaReadObjects_100000_1.txt", header=TRUE, sep="#")
#data100000 = calulateMeanDataTotaltime("data/java/final5/resultJavaReadObjects_100000_", 36)
#data100000$size <-100000 

# load data for 1000000 objects read 
# data100000 <- read.delim("data/java/resultJavaReadObjects_1000000_1.txt", header=TRUE, sep="#")
# data1000000 = calulateMeanDataTotaltime("data/java/resultJavaReadObjects_1000000_")
# data1000000$size <-1000000 



# C Results 
##################################################################
# load data for 10 objects read 
#datac10 <- read.delim("data/C_Results/resultsC_10.txt", header=TRUE, sep="#")
datac10 = calulateMeanDataTotaltime("data/C_Results/readobjects/result_cpp_readobjects_10_", 6)
datac10$size <-10 

# load data for 100 objects read 
# datac100 <- read.delim("data/C_Results/resultsC_100.txt", header=TRUE, sep="#")
datac100 = calulateMeanDataTotaltime("data/C_Results/readobjects/result_cpp_readobjects_100_", 6)
datac100$size <-100 


# load data for 1000 objects read 
#datac1000 <- read.delim("data/C_Results/resultsC_1000.txt", header=TRUE, sep="#")
datac1000 = calulateMeanDataTotaltime("data/C_Results/readobjects/result_cpp_readobjects_1000_", 6)
datac1000$size <-1000 


# load data for 10000 objects read 
#datac10000 <- read.delim("data/C_Results/resultsC_10000.txt", header=TRUE, sep="#")
datac10000 = calulateMeanDataTotaltime("data/C_Results/readobjects/result_cpp_readobjects_10000_", 6)
datac10000$size <-10000 

# load data for 10000 objects read 
# datac100000 <- read.delim("data/C_Results/resultsC_100000.txt", header=TRUE, sep="#")
datac100000 = calulateMeanDataTotaltime("data/C_Results/readobjects/result_cpp_readobjects_100000_", 6)
datac100000$size <-100000


# bind the data frames together 
# data <- rbind(data10, data100, data1000, data10000, data100000)
data <- rbind(datac10, datac100, datac1000, datac10000, datac100000)
#data1 <- rbind(data10, data100, data1000, data10000,  datac10, datac100, datac1000, datac10000)
# print(data)

##################################################################
##################################################################
##################################################################
##################################################################
#partJavaSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="JAVADEFAULT")
#partSeq <- vector()
#partSeq <-partJavaSeq[['totaltime']]


#partJava <- subset(data1, datatype == "Customer" & seq=="false" & method=="JAVADEFAULT")
#part <- vector()
#part <-partJava[['totaltime']]



# JSON results 
#partJsonSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="JSON")
#partJsonSeqV <- vector()
#partJsonSeqV <-partJsonSeq[['totaltime']]



#partJson <- subset(data1, datatype == "Customer" & seq=="false" & method=="JSON")
#partJsonV <- vector()
#partJsonV <-partJson[['totaltime']]



# PROTOCOL results 
#partPROTOCOLSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="PROTOCOL")
#partPROTOCOLSeqV <- vector()
#partPROTOCOLSeqV <-partPROTOCOLSeq[['totaltime']]

#partPROTOCOL <- subset(data1, datatype == "Customer" & seq=="false" & method=="PROTOCOL")
#partPROTOCOLV <- vector()
#partPROTOCOLV <-partPROTOCOL[['totaltime']]




# KRYO results 
#partKRYOSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="KRYO")
#partKRYOSeqV <- vector()
#partKRYOSeqV <-partKRYOSeq[['totaltime']]

#partKRYO <- subset(data1, datatype == "Customer" & seq=="false" & method=="KRYO")
#partKRYOV <- vector()
#partKRYOV <-partKRYO[['totaltime']]


# ByteBuffer results 
#partByteBufferSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="BYTEBUFFER")
#partByteBufferSeqV <- vector()
#partByteBufferSeqV <-partByteBufferSeq[['totaltime']]

#partByteBuffer <- subset(data1, datatype == "Customer" & seq=="false" & method=="BYTEBUFFER")
#partByteBufferV <- vector()
#partByteBufferV <-partByteBuffer[['totaltime']]


# BSON results 
#partBsonSeq <- subset(data, datatype == "Customer" & seq=="true" & method=="BSON")
#partBsonSeqV <- vector()
#partBsonSeqV <-partBsonSeq[['totaltime']]

#partBson <- subset(data1, datatype == "Customer" & seq=="false" & method=="BSON")
#partBsonV <- vector()
#partBsonV <-partBson[['totaltime']]


# C++  HANDCODED  results 
partHANDCODEDSeq <- subset(data, language="ReadTimeCPP", seq=="true" & method=="HANDCODED")
partHANDCODEDSeqV <- vector()
partHANDCODEDSeqV <-partHANDCODEDSeq[['totaltime']]

partHANDCODED <- subset(data, language="ReadTimeCPP",seq=="false" & method=="HANDCODED")
partHANDCODEDV <- vector()
partHANDCODEDV <-partHANDCODED[['totaltime']]



# C++  PROTOBUF  results 
#partCPROTOBUFSeq <- subset(data, language="ReadTimeCPP", seq=="true" & method=="PROTOBUF")
#partCPROTOBUFSeqV <- vector()
#partCPROTOBUFSeqV <-partCPROTOBUFSeq[['totaltime']]

#partCPROTOBUF <- subset(data1, language="ReadTimeCPP", seq=="false" & method=="PROTOBUF")
#partCPROTOBUFV <- vector()
#partCPROTOBUFV <-partCPROTOBUF[['totaltime']]


# C++  INPLACE  results 
partINPLACESeq <- subset(data, language="ReadTimeCPP",  seq=="true" & method=="INPLACE")
partINPLACESeqV <- vector()
partINPLACESeqV <- partINPLACESeq[['totaltime']]

partINPLACE <- subset(data, language="ReadTimeCPP", seq=="false" & method=="INPLACE")
partINPLACEV <- vector()
partINPLACEV <-partINPLACE[['totaltime']]


# C++  BOOST  results 
partBOOSTSeq <- subset(data, language="ReadTimeCPP", seq=="true" & method=="BOOST")
partBOOSTSeqV <- vector()
partBOOSTSeqV <-partBOOSTSeq[['totaltime']]

partBOOST <- subset(data, language="ReadTimeCPP", seq=="false" & method=="BOOST")
partBOOSTV <- vector()
partBOOSTV <-partBOOST[['totaltime']]


#################################################
#######     Plots       #########################
#################################################
pdf(file='Experiment_ReadObjects.pdf')

# old.par <- par(mfrow=c(1, 2))
old.par<-par(mfrow=c(1, 2), oma=c(0.1, 0.1, 0.1, 0.1),  pty="m")

op <- par(mar = c(4, 4, 0.1, 0.1))

# op <- par(mar = c(4,6,0.2,0.2) + 0.1)
# par(mar=c(4, 4, 1, 1))
# par(oma=c(0, 0, 0, 0))

x <- c(10, 100, 1000, 10000, 100000)
# x <- c(1:4)

# HANDCODED C++
plot(partHANDCODEDSeqV, log="y", type="o", pch=2, lty=2, col="deepskyblue", ylim=c(0.004, 120), axes=FALSE, ann=FALSE,  panel.first=abline(h= c(0.004, 0.01, 0.02,0.05,  0.1, 0.3,  0.5, 1,2, 4, 6, 10, 20, 30 ,60, 90, 120), v=c(1, 2, 3, 4, 5), lty=3, col="gray"))
# grid(10,10)


# Make x axis using one to 7 labels
axis(1, at=c(1, 2, 3, 4, 5), labels=c("10","100","1k","10k", "100k"), las=2 )
# axis(1, at=x, labels=c("10","100","1k","10k"))
# axis(1, at=x, lab=c("1","2","3","4"))

# Make y axis with horizontal labels that display ticks at 
# every 4 marks. 4*0:g_range[2] is equivalent to c(0,4,8,12).
#axis(2, las=1, at=0.2*0:g_range[2])
# axis(2, las=1, at = seq(0, 4, by = 0.2))
axis(2, las=1, at = c(0.004, 0.001, 0.01, 0.02,0.05,  0.1, 0.3,  0.5, 1, 2, 4, 6, 10, 20, 30 ,60, 90, 120), labels=c("0.004", "0.001", "0.01", "0.02", "0.05",  "0.1", "0.3", "0.5", "1","2",  "4","6" , "10", "20", "30", "60", "90", "120") )

#lines for JAVA Default
#lines(partSeq , type="o", pch=3, lty=2, col="green")
# lines(partJsonV, type="o", pch=22, lty=2, col="green")

#lines for BSON
#lines(partBsonSeqV , type="o", pch=4, lty=2, col="blue")

#lines for Protocol Buffer 
#lines(partPROTOCOLSeqV, type="o", pch=5, lty=2, col="red")

#lines for KRYO
#lines(partKRYOSeqV, type="o", pch=6, lty=2, col="green4")

#lines for ByteBuffer
#lines(partByteBufferSeqV, type="o", pch=7, lty=2, col="blue1")


#lines for BOOST C++ 
lines(partBOOSTSeqV, type="o", pch=8, lty=2, col="violet")

#lines for PROTOBUF C++ 
#lines(partCPROTOBUFSeqV, type="o", pch=9, lty=2, col="orange")

#lines for HANDCODED C++ 
#lines(partHANDCODEDSeqV, type="o", pch=10, lty=2, col="deepskyblue")

#lines for INPLACE C++ 
lines(partINPLACESeqV, type="o", pch=11, lty=2, col="blue3")



#print("partINPLACESeqV results")
#print(partINPLACESeqV)

#print("partHANDCODEDSeqV results")
#print(partHANDCODEDSeqV)


title(xlab="Number of Objects", col.lab=rgb(0,0.5,0))
title(ylab="Total Reading Time (sec) - log ", col.lab=rgb(0,0.5,0))
text(3, 0.005, "Sequential", cex=1.4)


box()

##############################################################
##################                   #########################
##################      Next Plot    #########################
##################                   #########################
##############################################################
op <- par(mar = c(4, 4, 0.1, 0.1))

# op <- par(mar = c(4,4,0.2,1))
# par(mar=c(4, 4, 1, 1))
# par(oma=c(0, 0, 0, 0))
# plot(partSeq, log="y")

x <- c(10, 100, 1000, 10000,100000) 
# HANDCODED C++
plot(partHANDCODEDV, log="y", type="o", pch=2, lty=2, col="deepskyblue", ylim=c(0.01, 30), axes=FALSE, ann=FALSE,  panel.first=abline(h= c(0.01, 0.02,0.05,  0.1, 0.3,  0.5, 1, 2, 4, 6, 10, 20 ,30), v=c(1, 2, 3, 4), lty=3, col="gray"))

# plot(x, partSeq, type="b", pch=21, col="red",  yaxt="n", lty=3, xlab="", ylab=")

# Make x axis using one to 7 labels
axis(1, at=c(1, 2, 3, 4,5), lab=c("10", "100","1k","10k","100k") , las = 2 )
axis(2, las=1, at = c(0.01, 0.02,0.05,  0.1, 0.3,  0.5, 1, 2, 4, 6, 10, 20 ,30), labels=c("0.01", "0.02", "0.05",  "0.1", "0.3", "0.5", "1", "2", "4","6" , "10", "20", "30") )


#lines for JAVA Default
#lines(part , type="o", pch=3, lty=2, col="green")


#lines for BSON
#lines(partBsonV , type="o", pch=4, lty=2, col="blue")

#lines for Protocol Buffer 
#lines(partPROTOCOLV, type="o", pch=5, lty=2, col="red")



#lines for KRYO
#lines(partKRYOV, type="o", pch=6, lty=2, col="green4")


#lines for ByteBuffer
#lines(partByteBufferV, type="o", pch=7, lty=2, col="blue1")


#lines for BOOST C++ 
lines(partBOOSTV, type="o", pch=8, lty=2, col="violet")

#lines for PROTOBUF C++ 
#lines(partCPROTOBUFV, type="o", pch=9, lty=2, col="orange")

#lines for HANDCODED C++ 
#lines(partHANDCODEDV, type="o", pch=10, lty=2, col="deepskyblue")

#lines for INPLACE C++ 
lines(partINPLACEV, type="o", pch=11, lty=2, col="blue3")

#print("INPLACE results and Boost")
#print(partINPLACEV)

#print("BOOST results")
#print(partBOOSTV)


title(xlab="Number of Objects", col.lab=rgb(0,0.5,0))
title(ylab="Total Reading Time (sec) - log ", col.lab=rgb(0,0.5,0))

text(2.3, 25, "Random", cex=1.4)

# Create box around plot
box()

par(old.par)
par(xpd=TRUE)

#legend(3.1, 0.16, c("Java JSON GZIP",  "Java Default" , "Java BSON" , "Java Protocol", "Java Kryo", "Java ByteBuffer", "C++ Boost",  "C++ Protocol",  "C++ HandCoded", "C++ InPlace"), cex=0.9,  col=c("darkred", "green","blue", "red","green4", "blue1", "violet", "orange", "deepskyblue" , "blue3"), pch=2:11, lty=2:2);
legend(3.1, 0.16, c("C++ Boost",  "C++ HandCoded", "C++ InPlace"), cex=0.9,  col=c( "violet",  "deepskyblue" , "blue3"), pch=2:11, lty=2:2);
# par(xpd=TRUE)
